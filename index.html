<html>
<head>
	<title>Flood</title>
	<meta charset='UTF-8'/>
	<script src="https://unpkg.com/react@latest/dist/react.js"></script>
   <script src="https://unpkg.com/react-dom@latest/dist/react-dom.js"></script>
	<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

	<style>
		.square {
			border: 1px solid #FFF;
			height: 50px;
			width: 50px;
		}

		.board-column {
			float: left;
		}

		.status {
			font: 36px bold, sans-serif;
		}

		.solution {
			font: 18px bold, sans-serif;
		}

		.solveBtn {
			margin: 10px;
			font: 24px bold, sans-serif;
		}

		.resetBtn {
			margin: 10px;
			font: 24px bold, sans-serif;
		}
	</style>
</head>

<body>
	<div id="errors"></div>
	<div id="container"></div>
</body>




<script type='text/babel'>

//////////////////////////////////////////////////
// TODOS
// set Game.size and Game.numColors from input
// count number of moves
// find most efficient solution
//////////////////////////////////////////////////

// needs to display color and send it back up on click
function Square(props) {
	return (
		<button className="square" style={{backgroundColor: props.color,}} onClick={() => props.onClick()}></button>
	);
}

// renders board based on info from Game
class Board extends React.Component {
	renderSquare(x, y, color) {
		return <Square color={color} onClick={() => this.props.onClick(x,y)}/>;
	}

	render() {
		const colors = this.props.colors.slice();

		return (
   		<div className="board">
   			{colors.map((column, x) =>
   				<span className="board-column" key={"column"+x}>{column.map((color, y) => 
   				   <div className="square" key={x+""+y}>{this.renderSquare(x, y, color)}</div>)}
   				</span>
   			)}
   		</div>
   	);
	};
}

// game logic and state
class Game extends React.Component {

	constructor(props) {
		super(props);

		this.state = {
			status: "Click any square",
			colors: Array(this.props.size),
			solution: "",
		}

		this.numberToColor = {
			0: "red",
			1: "green",
			2: "blue",
			3: "yellow",
			4: "purple",
			5: "orange",
			6: "black"
		}

		this.connectivity = Array(this.props.size);
		this.startingConnectivity = Array(this.props.size);
		this.startingColors = Array(this.props.size);
		this.tempColors = Array(this.props.size);

		// initialize colors and connectivity arrays
		let colorInt;
	   for (let x = 0; x < this.props.size; x++) {
	    	this.state.colors[x] = Array(this.props.size);
	    	this.startingColors[x] = Array(this.props.size);
	    	this.connectivity[x] = Array(this.props.size);
			for (let y = 0; y < this.props.size; y++) {

				// randomize starting state
				colorInt = Math.floor(Math.random() * this.props.numColors);
				this.state.colors[x][y] = this.numberToColor[colorInt];
				this.startingColors[x][y] = this.numberToColor[colorInt];
				this.connectivity[x][y] = false;
			}
		}
		this.tempColors = this.duplicate2dArray(this.startingColors);
		this.startingConnectivity = this.duplicate2dArray(this.connectivity);
	}

	componentDidMount() {
		this.updateConnectivity();
	}

	componentDidUpdate() {
		this.updateConnectivity();
	}

	displayTempColors() {
		this.setState({colors: this.tempColors});
	}

	// determine which squares are part of the flood
	// uses tempColors instead of state.colors
	updateConnectivity() {
		let connectivity = this.duplicate2dArray(this.connectivity);
		const size = this.props.size;
		const colors = this.duplicate2dArray(this.tempColors);
		const activeColor = colors[0][0];

		// keep track of which squares have already been checked
		let checked = Array(size);
		for (let i = 0; i < size; i++) {
			checked[i] = Array(size)
			for (let j = 0; j < size; j++) {
				checked[i][j] = false;
			}
		}

		let square;
		let queue = [{x: 0, y: 0}];
		while (queue.length > 0) {
			square = queue.shift();

			// NOTE could be optimized to compare against the checked matrix prior to pushing
			if (checked[square.x][square.y]) {
				continue;
			}

			if (colors[square.x][square.y] === activeColor) {
				connectivity[square.x][square.y] = true;

				// add adjacent squares to queue
				if (square.x > 0) { queue.push({x: (square.x - 1), y: square.y}); }
				if (square.x < size - 1) { queue.push({x: (square.x + 1), y: square.y}); }
				if (square.y > 0) { queue.push({x: square.x, y: (square.y - 1)}); }
				if (square.y < size - 1) { queue.push({x: square.x, y: (square.y + 1)}); }
			}

			checked[square.x][square.y] = true;
		}

		this.connectivity = this.duplicate2dArray(connectivity);
	}

	// change color of all squares which are connected to the top left
	changeFloodColor(newColor) {
		let colors = this.duplicate2dArray(this.tempColors);
		const connectivity = this.duplicate2dArray(this.connectivity);
		const size = this.props.size;

		for (let i = 0; i < size; i++) {
			for (let j = 0; j < size; j++) {
				if (connectivity[i][j]) {
					colors[i][j] = newColor;
				}
			}
		}

		this.tempColors = this.duplicate2dArray(colors);
	}

	// determine the next unique move
	// traverses the tree of all possible move sequences
	// 
	// currentPath (array<int>) the path leading to the current move
	// numMoves (int) how many moves have been taken AKA tree depth
	//
	// arguments should be (currentPath, currentPath.length)
	// all examples assume numColors = 3
	findNextMove(currentPath, numMoves) {
		const numColors = this.props.numColors;
		let currentMove, nextMove;

		if (currentPath.length == 0) {

			// build starting path of numMoves length
			// this will always take the form 01010[...]
			numMoves++;
			currentPath.push(0);
			while (currentPath.length < numMoves) {
				currentMove = currentPath.pop();
				nextMove = currentMove == 0 ? 1 : 0;
				currentPath.push(currentMove, nextMove);
			}
		
		} else {
			// increment last move, if possible
			// and rebuild path to length of numMoves if necessary

			currentMove = currentPath.pop();
			if (currentMove < numColors - 1) {
				if (currentMove + 1 != currentPath[currentPath.length - 1]) {
					// simple incremenation is possible
					// ie 020 => 021
					currentPath.push(currentMove + 1);

				} else if (currentMove + 2 < numColors) {
					// next incremenation is a duplicate, but extra incrementation is valid 
					// ie 010 => 012
					currentPath.push(currentMove + 2);

				} else {
					// next incremenation is a duplicate, and extra incrementation is invalid
					// requires modification of parent
					// ie 021 => 101
					return this.findNextMove(currentPath, numMoves);

				}
			} else {
				// move up a level and try again
				return this.findNextMove(currentPath, numMoves);
			}

			// currentPath is now valid and incremented
			// but may be too short
			while (currentPath.length < numMoves) {
				// like the currentPath.length == 0 case, fills out remainder with 0101[...]
				currentMove = currentPath.pop();
				nextMove = currentMove == 0 ? 1 : 0;
				currentPath.push(currentMove, nextMove);
			}

		}
		
		return currentPath;
	}

	// find shortest solution
	solve() {
		let currentPath = [0];

		while (!this.gameIsWon()) {
			this.resetBoard(false);
			currentPath.map(function(moveInt) {
				this.changeFloodColor(this.numberToColor[moveInt]);
				this.updateConnectivity();
			}, this);

			if (this.gameIsWon()) {
				break;
			} else {
				currentPath = this.findNextMove(currentPath, currentPath.length);
			}
		}

		let solutionText = currentPath.reduce((prev, curr) => prev.concat(this.numberToColor[curr] + ", "), "");
		solutionText = solutionText.slice(0,-2)

		this.resetBoard(true);
		this.setState({solution: solutionText});
	}

	// checks if connectivity matrix is all true
	gameIsWon() {
		const connectivity = this.duplicate2dArray(this.connectivity);
		const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);

		if (flatten(connectivity).reduce((prev, curr) => prev && curr)) {
			return true;
		}

		return false;
	}

	resetBoard(shouldDisplay) {
		this.tempColors = this.startingColors;
		this.connectivity = this.startingConnectivity;
		this.updateConnectivity();
		
		if (shouldDisplay) {
			this.displayTempColors();
			this.setState({status: "Click any square"});
		}
	}

	// creates a deep copy of a 2d array
	duplicate2dArray(targetArray) {
		let dupArray = new Array();
		targetArray.map((e) => dupArray.push(e.slice()));
		return dupArray;
	}

	// change flood color to match the square that was clicked
	handleClick(x,y) {
		this.changeFloodColor(this.state.colors[x][y]);
		this.updateConnectivity();
		if (this.gameIsWon()) {
			this.setState({status: "You win!"});
		}
		this.displayTempColors();
	}

	render() {
		return (
			<div>
				<Board colors={this.state.colors} onClick={(x,y) => this.handleClick(x,y)}/>
				<div className="status">{this.state.status}</div>
				<button className="solveBtn" onClick={() => this.solve()}>Solve</button>
				<button className="resetBtn" onClick={() => this.resetBoard(true)}>Reset</button>
				<div className="solution">{this.state.solution}</div>
			</div>
		);
	}
}

ReactDOM.render(
	<Game size={5} numColors={3}/>,
	document.getElementById('container')
);
</script>

</html>