<html>
<head>
	<title>Flood</title>
	<meta charset='UTF-8'/>
	<script src="https://unpkg.com/react@latest/dist/react.js"></script>
   <script src="https://unpkg.com/react-dom@latest/dist/react-dom.js"></script>
	<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

	<style>
		.square {
			border: 1px solid #FFF;
			height: 50px;
			width: 50px;
		}

		.board-column {
			float: left;
		}

		.status {
			font: 36px bold, sans-serif;
		}
	</style>
</head>

<body>
	<div id="errors"></div>
	<div id="container"></div>
</body>




<script type='text/babel'>

//////////////////////////////////////////////////
// TODOS
// set Game.size and Game.numColors from input
// count number of moves
// find most efficient solution
//////////////////////////////////////////////////

// needs to display color and send it back up on click
function Square(props) {
	return (
		<button className="square" style={{backgroundColor: props.color,}} onClick={() => props.onClick()}></button>
	);
}

// renders board based on info from Game
class Board extends React.Component {
	renderSquare(x, y, color) {
		return <Square color={color} onClick={() => this.props.onClick(x,y)}/>;
	}

	render() {
		const colors = this.props.colors.slice();

		return (
   		<div className="board">
   			{colors.map((column, x) =>
   				<span className="board-column" key={"column"+x}>{column.map((color, y) => 
   				   <div className="square" key={x+""+y}>{this.renderSquare(x, y, color)}</div>)}
   				</span>
   			)}
   		</div>
   	);
	};
}

// game logic and state
class Game extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			size: this.props.size,
			numColors: this.props.numColors,
			colors: Array(this.props.size),
			connectivity: Array(this.props.size),
			status: "Click any square",
		}

		// initialize colors and connectivity arrays
		let colorInt;
	   for (let x = 0; x < this.state.size; x++) {
	    	this.state.colors[x] = Array(this.state.size);
	    	this.state.connectivity[x] = Array(this.state.size);
			for (let y = 0; y < this.state.size; y++) {

				// randomize starting state
				colorInt = Math.floor(Math.random() * this.state.numColors);
				this.state.colors[x][y] = this.numberToColor(colorInt);
				this.state.connectivity[x][y] = false;
			}
		}

		// BUG race condition when this.state hasn't updated yet after constructor
		this.updateConnectivity();
	}

	numberToColor(number) {
		switch(number) {
		case 0:
			return "red";
		case 1:
			return "green"
		case 2:
			return "blue"
		case 3:
			return "yellow"
		case 4:
			return "purple"
		case 5:
			return "orange"
		default:
			return "black"
		}
	}

	// determine which squares are part of the flood
	updateConnectivity() {
		let connectivity = this.state.connectivity.slice();
		const size = this.state.size;
		const colors = this.state.colors.slice();
		const activeColor = colors[0][0];

		// keep track of which squares have already been checked
		let checked = Array(size);
		for (let i = 0; i < size; i++) {
			checked[i] = Array(size)
			for (let j = 0; j < size; j++) {
				checked[i][j] = false;
			}
		}

		let square;
		let queue = [{x: 0, y: 0}];
		while (queue.length > 0) {
			square = queue.shift();

			// NOTE could be optimized to compare against the checked matrix prior to pushing
			if (checked[square.x][square.y]) {
				continue;
			}

			if (colors[square.x][square.y] === activeColor) {
				connectivity[square.x][square.y] = true;

				// add adjacent squares to queue
				if (square.x > 0) { queue.push({x: (square.x - 1), y: square.y}); }
				if (square.x < size - 1) { queue.push({x: (square.x + 1), y: square.y}); }
				if (square.y > 0) { queue.push({x: square.x, y: (square.y - 1)}); }
				if (square.y < size - 1) { queue.push({x: square.x, y: (square.y + 1)}); }
			}

			checked[square.x][square.y] = true;
		}

		this.checkForWin();
		this.setState({connectivity: connectivity});
	}

	// change color of all squares which are connected to the top left
	changeFloodColor(newColor) {
		let colors = this.state.colors.slice();
		const connectivity = this.state.connectivity.slice();
		const size = this.state.size;

		for (let i = 0; i < size; i++) {
			for (let j = 0; j < size; j++) {
				if (connectivity[i][j]) {
					colors[i][j] = newColor;
				}
			}
		}

		this.setState({colors: colors}, this.updateConnectivity);
	}

	// change flood color to match the square that was clicked
	handleClick(x,y) {
		this.changeFloodColor(this.state.colors[x][y]);
	}

	// checks if connectivity matrix is all true
	checkForWin() {
		const connectivity = this.state.connectivity.slice();
		const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);

		if (flatten(connectivity).reduce((prev, curr) => prev && curr)) {
			this.setState({status: "You win!"});
		}
	}

	// determine the next unique move
	// traverses the tree of all possible sequences moves given a number of colors
	// 
	// currentPath (array<int>) the path leading to the current move
	// numMoves (int) how many moves have been taken AKA tree depth
	// starting arguments should be ([0], 1)
	// all examples assume numColors = 3
	findNextMove(currentPath, numMoves) {
		const numColors = this.state.numColors;
		let currentMove, nextMove;

		if (currentPath.length == 0) {

			// build starting path of numMoves length
			// this will always take the form 01010[...]
			numMoves++;
			currentPath.push(0);
			while (currentPath.length < numMoves) {
				currentMove = currentPath.pop();
				nextMove = currentMove == 0 ? 1 : 0;
				currentPath.push(currentMove, nextMove);
			}
		
		} else {
			// increment last move, if possible
			// and rebuild path to length of numMoves if necessary

			currentMove = currentPath.pop();
			if (currentMove < numColors - 1) {
				if (currentMove + 1 != currentPath[currentPath.length - 1]) {
					// simple incremenation is possible
					// ie 020 => 021
					currentPath.push(currentMove + 1);

				} else if (currentMove + 2 < numColors) {
					// next incremenation is a duplicate, but extra incrementation is valid 
					// ie 010 => 012
					currentPath.push(currentMove + 2);

				} else {
					// next incremenation is a duplicate, and extra incrementation is invalid
					// requires modification of parent
					// ie 021 => 101
					return this.findNextMove(currentPath, numMoves);

				}
			} else {
				// move up a level and try again
				return this.findNextMove(currentPath, numMoves);
			}

			// currentPath is now valid and incremented
			// but may be too short
			while (currentPath.length < numMoves) {
				// like the currentPath.length == 0 case, fills out remainder with 0101[...]
				currentMove = currentPath.pop();
				nextMove = currentMove == 0 ? 1 : 0;
				currentPath.push(currentMove, nextMove);
			}

		}
		
		return currentPath;

	}

	solve() {
		let currentPath = [0];
		while (currentPath.length < 4) {
			currentPath = this.findNextMove(currentPath, currentPath.length);
			console.log(currentPath)
		}
	}

	render() {
		return (
			<div>
				<Board colors={this.state.colors} onClick={(x,y) => this.handleClick(x,y)}/>
				<div className="status">{this.state.status}</div>
				<button className="solveBtn" onClick={() => this.solve()}>Solve</button>
			</div>
		);
	}
}

ReactDOM.render(
	<Game size={5} numColors={3}/>,
	document.getElementById('container')
);
</script>

</html>